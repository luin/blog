<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Code Game | Zihua Li</title>
      <link href="http://zihua.li/feed" type="application/rss+xml" rel="alternate" title="Zihua Li RSS Feed" />
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>
    <link rel='stylesheet'  href='http://zihua.li/theme/css/normalize.css' type='text/css' media='all' />
    <link rel='stylesheet'  href='http://zihua.li/theme/css/style.css' type='text/css' media='all' />
    <link rel='stylesheet'  href='http://zihua.li/theme/css/highlight.css' type='text/css' media='all' />
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link rel="author" href="https://plus.google.com/107380206942623407058/posts" />
    <!--[if lt IE 9]> <script src="http://zihua.li/theme/js/vendor/html5shiv.js"></script> <![endif]-->
</head>
<body>
  <section class="l-cover">
    <header id="banner" class="body">
      <div class="header-avatar"><a href="http://zihua.li/"><img src="http://zihua.li/theme/images/avatar.png" width="64" height="64" alt="" /></a></div>
      <h1 class="site-name"><a href="http://zihua.li/">Zihua Li</a></h1>
      <p class="description">
        美工、全栈码农（Web, iOS）<br>90 后，法号 Luin<br />
        [<a href="http://zihua.li/pages/about/">关于</a>, <a href="http://zihua.li/pages/novel/">小说</a>]
      </p>
      <ul class="social-links">
        <li><a href="https://twitter.com/luinlee">Twitter</a></li>
        <li><a href="https://github.com/luin">GitHub</a></li>
        <li><a href="http://dribbble.com/luin">Dribbble</a></li>
      </ul>
    </header>
  </section>
  <section class="l-content">
    <div class="inner">
<article>
  <header>
    <p class="article-meta" title="2014-11-07T00:00:00">07 Nov 2014</p>
    <h2 class="article-title">Code Game</h3>
  </header>
  <div class="typo article-body">
    <p>Code Game 是我最近一个月在做的业余项目，这篇文章主要目的是介绍我在开发 Code Game 中总结的经验，并顺便回答了我之前提到过的“为什么不应该用 CoffeeScript” 和 “为什么不应该用 Less/Sass”这两个问题。</p>
<h2>Code Game 是什么</h2>
<p>Code Game 是一个 AI 脚本对战平台，网址是 <a href="http://codegame.org">http://codegame.org</a>，玩家可以通过编写 JavaScript 脚本来控制游戏中的角色并与平台上的其他玩家进行竞赛。</p>
<p>Code Game 的灵感来源于大学时我在北航 MSTC(Microsoft Technology Club) 参与的 BigTank 项目。BigTank 是一个使用 C# 开发的 3D 坦克大战游戏，与传统坦克大战游戏由玩家直接操控坦克不同，BigTank 的玩家需要通过编写 Lua 脚本来分析游戏局势并控制自己的坦克行动。基于 BigTank，MSTC 举办了编程挑战赛，在北航获得了很好的反响。然而限于开发时间和当时的技术水平，BigTank 本身存在很多不足，包括游戏规则欠考虑、脚本解析器存在不少 Bug 等。种种这些都或多或少地影响了比赛的精彩程度，所以一个月前我突发奇想，决定重新开发一套类似 BigTank 的平台来弥补遗憾。</p>
<h2>功能</h2>
<p>Code Game 的页面构成很简单，挨个介绍也并不会花费很多篇幅。首先是个人主页页面，在这个页面中玩家可以看到自己的资料和 AI 的排名：</p>
<p><img src="http://zihua.li/images/2014-11-12_codegame/profile.png" alt="个人主页" class="fill" /></p>
<p>点击“编写我的 AI”按钮就进入到了脚本编写页面，该页面由支持代码高亮和自动补全的在线编辑器、可以实时看到脚本的运行效果的预览画面以及用来查看调试信息的控制台组成：</p>
<p><img src="http://zihua.li/images/2014-11-12_codegame/editor.png" alt="编辑器" class="fill" /></p>
<p>Code Game 每天会根据 AI 的胜率更新一次排行榜，可以看到每个玩家的排名，点击昵称可以进入其个人主页：</p>
<p><img src="http://zihua.li/images/2014-11-12_codegame/rank.png" alt="排行榜" class="fill" /></p>
<p>在他人的个人主页中可以向其发起挑战，下图所示为挑战页面：</p>
<p><img src="http://zihua.li/images/2014-11-12_codegame/game.png" alt="挑战页面" class="fill" /></p>
<h2>技术架构</h2>
<p>Code Game 的技术架构理念是在保证开发效率的前提下尽量降低技术栈复杂度。</p>
<h3>一、开发语言</h3>
<p>Code Game 使用 Node.js 开发，主要原因是我对 Node.js 较熟悉，另外 Node.js 与前端交互拥有天生的优势，对于脚本的沙箱处理非常方便，下文会介绍到。</p>
<h3>二、前端技术栈</h3>
<p>前端使用了 Gulp + Myth + Browserify + SketchTool。</p>
<ol>
<li>
<p>Gulp</p>
<p>平常的开发中，对于小型项目我一般会使用 Make 或 npm 的 scripts 来完成构建。而 Code Game 由于需要构建的内容比较多，所以使用了 Gulp。相较于更为流行的 Grunt，Gulp 以 Stream 的形式使得完成同样的构建任务时只需要编写更少的代码。在 Code Game 项目中，Gulp 中的任务分为两类：一类任务用来实现开发时实时编译，比如将基于 Myth 编写的 CSS 实时编译为可以被浏览器解析的 CSS，在开发过程一旦检测到源文件被修改，即自动编译；另一类任务用来执行生产环境的构建，比如编译 CSS、压缩 JavaScript 等。</p>
</li>
<li>
<p>Myth</p>
<p>Myth 在各种 CSS 预处理语言中绝对算不上流行，在 GitHub 上其共被 3000 余人 star，虽然不算少，但相比 Less 这样动辄一万多 star 的项目说是冷门也毫不过分。Myth 的优势和它的口号一样：“CSS the way it was imagined.”Myth 可以让你提前使用 CSS 的高级特性而无需考虑浏览器兼容问题。具体来说，写 CSS 时，当遇到 <code>transform</code> 属性时通常还需要额外写 <code>-webkit-transform</code> 来兼容 Safari 和 旧版的 Chrome，如果要兼容 IE 9，则更是要加上 <code>-ms-transform</code>。而使用 Myth 则不用操心各种浏览器前缀，Myth 会在编译过程中自动加上。Myth 与 Less、Sass 这样的预处理语言最大的区别就在于写 Myth 时你是在写 CSS，而写 Less 时你是在写 Less，写 Sass 时你是在写 Sass。这一点十分重要，因为把标准和草案都算上，CSS 语言本身已经足够完备了，它支持变量：</p>
<div class="highlight"><pre><span class="nd">:root</span> <span class="p">{</span>
  <span class="o">--</span><span class="nb">purple</span><span class="o">:</span> <span class="m">#847AD1</span><span class="p">;</span>
  <span class="o">--</span><span class="k">large</span><span class="o">:</span> <span class="m">10px</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">a</span> <span class="p">{</span>
  <span class="k">color</span><span class="o">:</span> <span class="n">var</span><span class="p">(</span><span class="o">--</span><span class="nb">purple</span><span class="p">);</span>
<span class="p">}</span>

<span class="nt">pre</span> <span class="p">{</span>
  <span class="k">padding</span><span class="o">:</span> <span class="n">var</span><span class="p">(</span><span class="o">--</span><span class="k">large</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>它支持数学计算：</p>
<div class="highlight"><pre><span class="n">pre</span> <span class="p">{</span>
  <span class="nl">margin:</span> <span class="n">calc</span><span class="p">(</span><span class="n">var</span><span class="p">(</span><span class="o">--</span><span class="n">large</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>甚至也支持颜色处理：</p>
<div class="highlight"><pre><span class="n">a</span> <span class="p">{</span>
  <span class="nl">color:</span> <span class="n">var</span><span class="p">(</span><span class="o">--</span><span class="n">purple</span><span class="p">);</span>
<span class="p">}</span>

<span class="nl">a:</span><span class="n">hover</span> <span class="p">{</span>
  <span class="nl">color:</span> <span class="n">color</span><span class="p">(</span><span class="n">var</span><span class="p">(</span><span class="o">--</span><span class="n">purple</span><span class="p">)</span> <span class="n">tint</span><span class="p">(</span><span class="mi">20</span><span class="o">%</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>可以说需要用到的特性 CSS 本身就已经具备了，那么何必再使用另一种语言呢？更何况 Less 和 Sass 这样“强大”的预处理语言在带来开发上的方便的同时也引入了很多问题，而大部分问题都可以归结到一点，即“你根本不是在写 CSS”。想象下面的 Less 代码：</p>
<div class="highlight"><pre><span class="p">.</span><span class="n">container</span> <span class="p">{</span>
  <span class="nl">width:</span> <span class="mi">960</span><span class="n">px</span><span class="p">;</span>
  <span class="nl">overflow:</span> <span class="n">hidden</span><span class="p">;</span>
  <span class="p">.</span><span class="n">main</span> <span class="p">{</span>
    <span class="nl">width:</span> <span class="mf">61.8</span><span class="o">%</span><span class="p">;</span>
    <span class="nl">float:</span> <span class="n">left</span><span class="p">;</span>
    <span class="p">.</span><span class="n">post</span> <span class="p">{</span>
      <span class="nl">background:</span> <span class="err">#</span><span class="n">f00</span><span class="p">;</span>
      <span class="p">.</span><span class="n">title</span> <span class="p">{</span>
        <span class="nl">position:</span> <span class="n">absolute</span><span class="p">;</span>
        <span class="nl">background:</span> <span class="n">url</span><span class="p">(</span><span class="s">&quot;images/header-image.jpg&quot;</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Less 支持的样式嵌套很容易诱使开发者写出上面这样层层嵌套的代码，编译成 CSS 后，最长的 Selector 是<code>.container .main .post .title</code>，以纯 CSS 的眼光来看，更应该减少嵌套层数来提高性能（比如改成<code>.post .title</code>），亦或是优化类名来实现样式模块化（比如把<code>.post .title</code>改成<code>.post-title</code>）。然后一旦用 Less 写出来，就很难以 CSS 的角度来审视本就要编译成 CSS 的代码。很多使用 Less 或 Sass 的公司的 Style Guide 都会明确禁止过度嵌套，然而与其以规范来要求开发者，不如就单纯地使用 CSS，并享受 Myth 提供的便利来的方便自然。</p>
</li>
<li>
<p>Browserify</p>
<p>Browserify 可以非常方便地实现前端 JavaScript 的模块化。使用 Browserify，你可以在前端的 JavaScript 中使用和 Node.js 一样的模块加载方式，即 <code>require('modules')</code>，使得前后端 JavaScript 模块级复用成为了可能。在 Code Game 中的游戏沙盒部分的所有模块曾经是前后端共用的，当用户在编辑器中预览时沙盒运行在前端，当与其他玩家竞赛时，沙盒运行在后端。同时 Browserify 作为一个构建工具，并不影响前端脚本的加载逻辑，换言之在使用 Browserify 的同时依然可以使用 RequireJS、SeaJS 这样的 Module Loader 以及 Combo Handler 等技术。</p>
<p>除了 Browserify 以外，Code Game 并没有使用其他的预处理工具。也并没有使用 CoffeeScript、LiveScript 这样的语言替代 JavaScript，原因在于 JavaScript 在前端工程方面本身已经足够优秀，而 CoffeeScript 和 LiveScript 这样的语言在提供更“现代”的语法同时，也会大大降低代码的可控性。同 Less 和 CSS 的关系一样，写 CoffeeScript 与写 JavaScript 的思路在很多情况下并不相同。比如 CoffeeScript 的函数调用无需写“()”，使得易读性大为下降（比较 <code>console.log x + 1</code> 和 <code>console.log x +1</code>），同时也引入了很多细节问题（比如无法实现 JavaScript 里的具名匿名函数 <code>var func = function func() {}</code>），另外 CoffeeScript 生成的 JavaScript 虽然有很多最佳实践，但总体并不易读，包括很容易生成冗余代码，比如：</p>
<div class="highlight"><pre><span class="n">greet</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="k">for</span> <span class="n">time</span> <span class="n">in</span> <span class="p">[</span><span class="err">&#39;</span><span class="n">morning</span><span class="err">&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">afternoon</span><span class="err">&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">nignt</span><span class="err">&#39;</span><span class="p">]</span>
    <span class="n">console</span><span class="p">.</span><span class="n">log</span> <span class="s">&quot;Good #{time}, #{name}!&quot;</span>

<span class="n">greet</span> <span class="err">&#39;</span><span class="n">Bob</span><span class="err">&#39;</span>
</pre></div>


<p>会生成：</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">greet</span><span class="p">;</span>

<span class="nx">greet</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">time</span><span class="p">,</span> <span class="nx">_i</span><span class="p">,</span> <span class="nx">_len</span><span class="p">,</span> <span class="nx">_ref</span><span class="p">,</span> <span class="nx">_results</span><span class="p">;</span>
  <span class="nx">_ref</span> <span class="o">=</span> <span class="cp">[</span><span class="s1">&#39;morning&#39;</span><span class="p">,</span> <span class="s1">&#39;afternoon&#39;</span><span class="p">,</span> <span class="s1">&#39;nignt&#39;</span><span class="cp">]</span><span class="p">;</span>
  <span class="nx">_results</span> <span class="o">=</span> <span class="cp">[]</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_len</span> <span class="o">=</span> <span class="nx">_ref</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_len</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">time</span> <span class="o">=</span> <span class="nx">_ref</span><span class="cp">[</span><span class="nx">_i</span><span class="cp">]</span><span class="p">;</span>
    <span class="nx">_results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Good &quot;</span> <span class="o">+</span> <span class="nx">time</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;!&quot;</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">_results</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">greet</span><span class="p">(</span><span class="s1">&#39;Bob&#39;</span><span class="p">);</span>
</pre></div>


<p>语句表达式化是好的，免去写 <code>return</code> 是好的，但是 CoffeeScript 终究不是 JavaScript，终究还是要编译成 JavaScript。本来简单的代码变得如此复杂，即使表面再光鲜，即使能通过 JSLint 又有什么意义呢。CoffeeScript 对于初级 JavaScript 程序员来说，可以帮助他们避免很多 JavaScript 的陷阱，也能更顺畅地写出最佳实践的代码，但一个富有经验的 JavaScript 开发者写出的 JavaScript 绝对要比 CoffeeScript 的可控性来的高。</p>
</li>
<li>
<p>SketchTool</p>
<p>之前做设计一直使用 Photoshop，直到见识到 Sketch 的威力后便很少碰 Photoshop 了。网上有很多文章讨论两者的设计优劣，所以不再赘述。这里主要介绍对开发者来说 Sketch 的优势。</p>
<p>相较 Photoshop，Sketch 最大的优势就是可以实现切图自动化，对于每个图层来都可以指定其导出格式以及文件名（如下图所示）。</p>
<p><img src="http://zihua.li/images/2014-11-12_codegame/sketch.png" alt="个人主页" class="fill" /></p>
<p>更重要的是，Sketch 官方提供了命令行工具 SketchTool，可以通过命令将 Sketch 源文件按规则导出成图像文件，这意味着配合 Gulp 可以实现当修改 Sketch 的设计后自动切图。同时由于 Sketch 的文件普遍很小，甚至可以将其放入版本库中来维护其版本（自然这样也就无需将切好的图片放入版本库，因为这些图片可以由 Gulp 构建脚本生成）。</p>
</li>
</ol>
<h3>三、沙盒的实现</h3>
<p>在 Code Game 中最关键的一环就是沙盒的实现了。因为涉及到对战，所以比赛时双方选手的代码自然不能运行在前端。所以 Code Game 采用如下流程来实现脚本对战：</p>
<ol>
<li>玩家在编辑器调试代码并保存</li>
<li>服务端将玩家的代码保存到 MySQL 数据库中</li>
<li>进行比赛时，服务端调集双方的代码，并在后端解析运行</li>
<li>运行结束后，将游戏“录像”传回前端</li>
<li>前端解析“录像”，并以动画形式展现给用户</li>
</ol>
<p>下面分三个部分着重介绍 3 和 5 两个过程。</p>
<h4>在后端解析玩家代码</h4>
<p>这一过程是沙盒的意义所在。因为后端使用 Node.js 开发，而玩家的脚本本身是 JavaScript，所以解析脚本的过程本身就很简单，一个 <code>eval()</code> 即可。然而 <code>eval()</code> 并不能限制用户的脚本权限，即使用 <code>eval</code> 解析运行用户的脚本会使得用户的脚本可以访问 Node.js 的各种库函数，也会污染 Node.js 的全局变量，同时也无法对脚本的运行时间进行任何限制。</p>
<p>这个问题的解决方式是使用 Node.js 提供的 <code>script.runInNewContext()</code> 函数。<code>runInNewContext()</code> 函数接受两个参数，一个是全局变量对象，这个对象包含脚本可以使用的全部全局变量，另一个是选项对象，可以在这个参数中指定脚本的超时时间。注意第二个参数是从 Node.js 0.11.x 开始支持的。</p>
<p>Code Game 定义了 <code>Sandbox</code> 类：</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Sandbox</span> <span class="o">=</span> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">sandbox</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nb">Math</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nb">parseInt</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">sandbox</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">sandbox</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sandbox</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>执行玩家脚本时，会实例化一个 <code>Sandbox</code> 实例作为全局变量对象，所以玩家能使用的全局变量只有 <code>Math</code> 和 <code>parseInt</code>。</p>
<p>玩家的脚本都会声明一个 <code>onIdle()</code> 函数（具体可以参加官网文档），这个函数可以在之前的 <code>Sandbox</code> 实例中获取到。接下来需要实现在坦克空闲时执行 <code>onIdle()</code> 函数，如果直接调用 <code>sandbox.onIdle()</code> 来执行的话就无法借助 <code>runInNewContext()</code> 函数来实现超时检测了，所以 Code Game 使用如下的方法来解决这个问题：</p>
<div class="highlight"><pre><span class="nx">Player</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">onIdle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">enemy</span><span class="p">,</span> <span class="nx">game</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">code</span> <span class="o">=</span> <span class="s1">&#39;onIdle(__self, __enemy, __game);&#39;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">script</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">script</span> <span class="o">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nx">createScript</span><span class="p">(</span><span class="nx">code</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">.</span><span class="nx">__self</span> <span class="o">=</span> <span class="nx">self</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">.</span><span class="nx">__enemy</span> <span class="o">=</span> <span class="nx">enemy</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">.</span><span class="nx">__game</span> <span class="o">=</span> <span class="nx">game</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">.</span><span class="nx">print</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">script</span><span class="p">.</span><span class="nx">runInNewContext</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">,</span> <span class="p">{</span>
      <span class="nx">timeout</span><span class="o">:</span> <span class="mi">1500</span>
    <span class="p">});</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">runTime</span> <span class="o">+=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">start</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>首先为 <code>__self</code>、<code>__enemy</code> 和 <code>__game</code> 这三个不对用户公开的全局变量赋相应的值，之后使用同样的 <code>Sandbox</code> 实例执行代码 <code>onIdle(__self, __enemy, __game)</code>。因为调用了 <code>runInNewContext()</code>，所以可以定义超时规则。</p>
<h4>录像文件的格式</h4>
<p>为了将代码的执行结果在前端展示给用户，最重要的是讲结果以一定规则记录下来，形成“录像”。由于前后端都是 JavaScript，所以录像文件的格式自然就是 JSON 了。录像文件中记录了每个对象（坦克、子弹等）在每个帧的位置和执行的动作，如：</p>
<div class="highlight"><pre><span class="p">[</span>
  <span class="p">[{</span>
    <span class="s2">&quot;objectId&quot;</span><span class="o">:</span> <span class="s2">&quot;6e723&quot;</span><span class="p">,</span>
    <span class="s2">&quot;type&quot;</span><span class="o">:</span> <span class="s2">&quot;tank&quot;</span><span class="p">,</span>
    <span class="s2">&quot;direction&quot;</span><span class="o">:</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span>
    <span class="s2">&quot;position&quot;</span><span class="o">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
    <span class="s2">&quot;action&quot;</span><span class="o">:</span> <span class="s2">&quot;go&quot;</span><span class="p">,</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="s2">&quot;objectId&quot;</span><span class="o">:</span> <span class="s2">&quot;4ad3f&quot;</span><span class="p">,</span>
    <span class="s2">&quot;type&quot;</span><span class="o">:</span> <span class="s2">&quot;tank&quot;</span><span class="p">,</span>
    <span class="s2">&quot;direction&quot;</span><span class="o">:</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
    <span class="s2">&quot;position&quot;</span><span class="o">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="s2">&quot;action&quot;</span><span class="o">:</span> <span class="s2">&quot;turn&quot;</span><span class="p">,</span>
    <span class="s2">&quot;value&quot;</span><span class="o">:</span> <span class="s2">&quot;left&quot;</span>
  <span class="p">}],</span>
  <span class="p">[{</span>
    <span class="s2">&quot;objectId&quot;</span><span class="o">:</span> <span class="s2">&quot;6e723&quot;</span><span class="p">,</span>
    <span class="s2">&quot;type&quot;</span><span class="o">:</span> <span class="s2">&quot;tank&quot;</span><span class="p">,</span>
    <span class="s2">&quot;direction&quot;</span><span class="o">:</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span>
    <span class="s2">&quot;position&quot;</span><span class="o">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
    <span class="s2">&quot;action&quot;</span><span class="o">:</span> <span class="s2">&quot;go&quot;</span>
  <span class="p">}],</span>
<span class="p">]</span>
</pre></div>


<p>首先录像的最外层是个数组，数组的一个元素代表一帧发生的所有动作。上面的示例录像中，第一帧坦克 6e723 从坐标 <code>(6, 7)</code> 向当前方向（右）前进了一个单位，同时坦克 4ad3f 向左转弯。第二帧坦克 6e723 从坐标 <code>(6, 8)</code> 继续前进了一步，同时坦克 4ad3f 没有执行任何操作。</p>
<p>理论上来说，录像文件中只要记录每个对象最初的状态和中间每步的动作即可使数据完整。然而可以注意到上面的录像样例中的每一帧都会把对象的所有信息记录下来，包括朝向和坐标。这使得前端播放录像时可以从任意一帧开始播放，而不用先从头开始初始化对象状态，另外由于 Code Game 的录像一般都很小（游戏限定 200 帧之内必须结束），所以这样记录从成本考量也可以接受。</p>
<h4>前端录像展示</h4>
<p>前端一律使用 CSS Animation 来实现动画。一般而言在前端实现动画有如下几种方式：</p>
<ol>
<li>通过 JavaScript 操作 DOM</li>
<li>使用 CSS Animation</li>
<li>Canvas 动画</li>
</ol>
<p>首先排除的是 Canvas。虽然 Canvas 的性能优异且兼容性良好，但是就播放录像这样简单的需求而言开发起来相对较为繁琐。其次排除的是 1，因为 JavaScript 实现的动画进行微小的位移时会出现抖动，而 Code Game 开发时希望对战页面可以在移动设备上播放，同时用户可以自定义播放速度，这就使得小位移的动画非常容易出现。</p>
<p>所以最后选择了 CSS Animation。录像中的每个拥有 <code>objectId</code> 属性的对象都会为其生成 DOM 节点，节点的 ID 由 <code>objectid</code> 构成，同时根据 <code>type</code> 的不同为其赋予不同的背景图。具体的动画实现以下面的动作为例：</p>
<div class="highlight"><pre><span class="p">{</span>
  <span class="s2">&quot;objectId&quot;</span><span class="o">:</span> <span class="s2">&quot;6e723&quot;</span><span class="p">,</span>
  <span class="s2">&quot;type&quot;</span><span class="o">:</span> <span class="s2">&quot;tank&quot;</span><span class="p">,</span>
  <span class="s2">&quot;direction&quot;</span><span class="o">:</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span>
  <span class="s2">&quot;position&quot;</span><span class="o">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
  <span class="s2">&quot;action&quot;</span><span class="o">:</span> <span class="s2">&quot;go&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>


<p>首先通过 JavaScript 找到 6e723 DOM 节点，然后根据当前游戏的 FPS 和地图大小 修改该节点的 Transition 时间，同时通过 <code>transform</code> 的 <code>translate</code> 操作来移动对象。</p>
<p>这样的实现存在一个问题，假设一个坦克不转向，一直前进了 10 个单位，前端会修改 10 次节点的 <code>transition</code> 和 <code>transform</code> 属性，每次只移动一个单位。而实际上对于这种情况可以优化成只修改一次属性，一次直接前进 10 个单位，当然 <code>transition</code> 的时间也要相应乘以 10。因为在游戏中坦克直线连续行进的地方很多，所以这种优化效果很明显。为此 Code Game 在前端会在解析录像前对录像进行优化，合并直线前进的操作。如上面的录像实例会被优化成：</p>
<div class="highlight"><pre><span class="p">[</span>
  <span class="p">[{</span>
    <span class="s2">&quot;objectId&quot;</span><span class="o">:</span> <span class="s2">&quot;6e723&quot;</span><span class="p">,</span>
    <span class="s2">&quot;type&quot;</span><span class="o">:</span> <span class="s2">&quot;tank&quot;</span><span class="p">,</span>
    <span class="s2">&quot;direction&quot;</span><span class="o">:</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span>
    <span class="s2">&quot;position&quot;</span><span class="o">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
    <span class="s2">&quot;action&quot;</span><span class="o">:</span> <span class="s2">&quot;go&quot;</span><span class="p">,</span>
    <span class="s2">&quot;frames&quot;</span><span class="o">:</span> <span class="mi">2</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="s2">&quot;objectId&quot;</span><span class="o">:</span> <span class="s2">&quot;4ad3f&quot;</span><span class="p">,</span>
    <span class="s2">&quot;type&quot;</span><span class="o">:</span> <span class="s2">&quot;tank&quot;</span><span class="p">,</span>
    <span class="s2">&quot;direction&quot;</span><span class="o">:</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
    <span class="s2">&quot;position&quot;</span><span class="o">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="s2">&quot;action&quot;</span><span class="o">:</span> <span class="s2">&quot;turn&quot;</span><span class="p">,</span>
    <span class="s2">&quot;value&quot;</span><span class="o">:</span> <span class="s2">&quot;left&quot;</span>
  <span class="p">}],</span>
  <span class="p">[],</span>
<span class="p">]</span>
</pre></div>


<p>坦克 6e723 在第一帧的动作中增加了 <code>frames: 2</code> 这个属性，表明一共前进了两帧，在之后播放动画时就可以大大降低修改 DOM 属性的次数了。</p>
  </div>
  <div class="hr"></div>
  <section class="article-share clearfix">
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    <div class="about-blog">
      <h4>关于我</h4>
      <p>美工 / 全栈码农（Web, iOS）/ 写过《Redis 入门指南》</p>
      <a href="https://twitter.com/luinlee" class="twitter-follow-button" data-show-count="false" data-lang="en">Follow @luinlee</a>
    </div>
    <div class="share">
      <h4>分享这篇文章</h4>
      <a class="icon-social icon-social-twitter-bird" href="http://twitter.com/share?text=Code Game&url=http://zihua.li/2014/11/codegame/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
      </a>
      <a class="icon-social icon-social-weibo" href="http://service.weibo.com/share/share.php?title=Code Game&url=http://zihua.li/2014/11/codegame/" onclick="window.open(this.href, 'weibo-share', 'width=550,height=435');return false;">
        <span class="hidden">微博</span>
      </a>
    </div>
  </section>
</article>
    </div>
  </section>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-46124852-1', 'zihua.li');
    ga('send', 'pageview');
  </script>
</body>
</html>